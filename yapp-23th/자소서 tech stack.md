# Yapp 23기 자소서를 바탕으로한 사전 질문 List-Up

### 도메인 구조가 무엇인가요?
- 각 도메인 별로 최상단 패키지를 구축한후, 내부에Layerd(Controller,Service,Repo,DTO)를 만들어 사용하는 방식입니다.
- 도메인 별로 코드가 응집되어 있어 유지보수관점에서 간편하다는 장점이 있습니다

### Spring Caching이 무엇인가요?
- Spring-Cache라이브러리를 이용하여 직접, Spring에서 제공하는 캐시매니저를 사용하는 방식과 Redis를 이용하는 방식 두가지가 있다.
- 동일한 리소스에대해 자주 요청이 되는 API에서 DBMS의 과부화를 줄이고자 사용됩니다.
- 다만 변경된 데이터를 가지고 있을 수도있으니 유의하며 코드를 짜야한다.
- 휘발성이기에 캐싱데이터를 애플리케이션 재구동이후에도 사용하고 싶다면, 캐시데이터를 저장하는 캐싱 서버를 두는 분산 캐싱을 해야한다.
- 캐시에 관한 전략을 잘세워야한다 Write Around, Look Aside

### 다른 종류의 테스트와 비교했을 때 단위 테스트의 특징이 뭔가요?
- 다른 인수테스트나 통합테스트의 경우 모듈단위의 작동이나 API의 흐름을 체킹하는데 사용된다.
- 말그대로 단위 즉, 일반적인 메서드를 기준으로 고립된 환경에서 테스트하기에 간단하고 빠른 테스트가 가능하다.
- 또한 리팩토링 신뢰도가 높습니다. Unit단위이기에 해당 로직의 변경을 고려할 수 도 있다.
- 이를 통해서 프로그램의 안정성이 높아지기도 합니다.

### 다른 프로젝트에서는 WebSocket을 사용하셨던데, 이 프로젝트에서는 SSE를 사용하신 이유가 있을까요? 둘의 차이점이 뭔가요?
- 두 기술의 가장 큰 차이점으로는 STOMP 프로토콜은 발행-구독 패턴 기반의 양방향 통신이라는 점이고, SSE는 서버에서 클라이언트의 별요청없이도 이벤트 발생시점에 단방향으로 데이터를 바인딩해줄 수 있다는 점입니다.
- 해당 프로젝트의 요구사항은 클라이언트가 애플리케이션을 구동하는 시점에 해당회원이 온라인이 되었다는 것을 실시간으로 알려주어야하였기에 Polling이나 소켓보다는 SSE를 선택하였습니다.

### 분신락
- 비관적 락, 낙관적 락 등에 대한 고민과 결론적으로 데이터베이스의 원자적 연산 쿼리를 활용하는 방법으로 문제를해결하고자 했다.
- MySQL의 네임드락을 이용하여 구현할 수도 있습니다. 메모리 자원을 추가로 사용할 필요가 없다는 장점을 가지고 있기에 오히려 좋을 수도 있습니다.
- 하지만 Redis를 이용해 분산락을 구현한다면, 빠르게 락을 획득 및 해제할 수도있고 추후 서버 분산환경 또한 고려할 수 있었기에 사용하였습니다.

#### Redisson 사용이유
- 기본적으로 Lettuce를 제공한다 스프링은
- 하지만 Lettuce로 분산 락을 구현하려면 반드시 스핀 락의 형태로 구현해야 한다는 단점이 있습니다. 스핀 락은 락을 획득하기 위해 SETNX라는 명령어로 계속해서 Redis에 락 획득 요청을 보내야 하는 구조
-  Redis에 많은 부하를 가하게 된다.
- 스핀 락을 사용하는 Lettuce 코드의 경우, 자체적인 타임아웃 구현이 존재하지않기에 락을 영원히 반환하지 않는다든가, 락을 획득하지 못해 무한 루프를 돈다든가 하는 문제를 해소하려면 애플리케이션 코드 상에서 타임아웃을 직접 구현해야한다.
- 반면 Redisson은 publish와 subscribe 기능을 지원합니다. Redisson은 이 기능을 통해 락을 획득 및 해제 하는 로직을 구현하고 있습니다.
- Redisson은 락 관련 기능은 락의 타임아웃도 구현해놨다는 장점
    - 락을 획득했을 때의 타임아웃과, 락 대기 타임아웃 모두


### 비동기 처리를 한 이유가 뭔가요? 이를 통한 이점, 반대로 단점은 뭐가 있을까요?
- 대규모 데이터를 전달할때 다수의 클라이언트에게 동시에 데이터를 전송하기 위해 응답성 향상을 목표로 사용했었다.
- 장점으로는 높은 동시성을 지원하여 빠른 응답 시간을 제공하며, 이에 따른 자원을 효율적으로 사용할 수있다.
- 하지만, 반대로 디버깅이나 코드 자체를 구현하는데 있어 복잡하며, 오버헤드또한 고려사항이다.

### RedisTemplate에서 사용되는 디자인 패턴과 해당 패턴을 사용하는 이유가 뭔가요?
- 템플릿 콜백 패턴이다.
- 템플릿 콜백 패턴을 사용하는 이유는 전략패턴의 특징을 이용하기 때문인데, 콜백에 어떤 구현체를 넘겨주는지에 따라 유연하게 변경되는 부분만 교체할 수있기 때문이다.

### Redis 랭킹 시스템 구현 어떻게 했나요?
- 굳이 Redis를 이용한 이유는 속도 개선을 위해 in-memory DB인 Redis를 사용했구요
- Redis Sorted Set을 이용하여, Timer Entity(ORM)에는 날짜와 해당날짜의 시간이 매핑되어있었기에, queryDsl을 이용하여 한달단위의 해당회원의 데이터를 조회함과 동시

### 서드파티 API를 사용하신 것 같은데, 이러한 API를 사용할 때 주의해야 할 점은 어떤게 있을까요?
- API 사용시 요청 및 응답 형식을 준수하고, 인증 방법을 정확히 이해하고 구현해야한다.
- 또한, 만약 API를 제공하는 회사의 서비스가 중단될경우 해당 서비스 로직을 재구성하거나, 운영에 문제가 생긴다.
- 예시로, 음원 스트리밍 사이트를 만들기 위해 레퍼런스를 참조하던 도중 FredBoat라는 서비스가 YoutubeAPI를 이용하던 도중 사용정책 위반으로 서비스가 중지된 사례도 본적이있다.

### 도메인에 맞는 패키지 분리 작업을 하셨다고 하셨는데, 이때 말씀하신 ‘도메인’이 어떤 의미인가요? ‘도메인’이란 무엇인가요?
- 간단히 말하면 해결하고자 하는 문제의 영역(내가 구현해야하고 기능을 개발하는 것에 있어 해당 개념을 갖고있는 것을 도메인이라고 할 수 있다.)
- 소프트웨어 관점에선 소프트웨어의 요구사항 , 문제 영역이라고 생각한다.
- 예시로 배달의민족의 경우 주문,배달,정산,결제 등이 도메인이라고 생각할 수 있다.

### 클린 아키텍처와 헥사고날 아키텍처의 차이점이 있나요?
- 소프트웨어의 구조를 내부에서부터 외부로 정의하는 데 중점을 두기에 비즈니스 논리를 핵심으로 하는 내부 계층을 강조하며, 외부 요소와의 결합을 최소화할 수 있습니다.
- **클린 아키텍처**
  - 의존성 규칙에 따름으로써 관심사가 분리된다
  - 본질적으로 테스트하기 쉬운 시스템을 만들 수 있다
  - 의존성 규칙이 가져오는 이점을 가져올 수 있다
  - Business Rule은 stable한 components로, 변경되기 쉬운 외부의 infrastructure components를 알아선 안되고 모른다.
- **공통점**
  - 클린 아키텍처와 마찬가지로 어디에도 의존하지 않는 도메인 객체들이 존재하고, 이들에 의존하는 서비스계층(또는 usecase 계층)이 존재합니다
  - 외부와 내부를 관심사로 분리한다는 점에서 비슷하나, 클린아키텍처는 엔티티를 애플리케이션의 핵심으로 두어 외부상황을 모르게한다.
  - DIP를 준수하여, 고수준과 저수준 모듈분리가 추상화를 통해 이루어진다.
- **차이점**
  - 구성도 자체가다르다.
  - 헥사고날 아키텍처는 "포트와 어댑터" 패턴을 강조하여 외부 시스템과의 통합을 단순화하고 유연성을 확보합니다
  - 클린 아키텍처에서는 **의존성은 내부 계층에서 외부 계층으**로 향합니다. 즉, 비즈니스 로직은 외부 요소에 독립적으로 유지됩니다.
  - 반면에 헥사고날 **아키텍처에서는 외부와 내부 사이의 의존성이 역전**되어, 외부 요소가 내부에 의존합니다
- **헥사고날**
  - 외부와의 통신을 인터페이스로 추상화하여 비즈니스 로직 안에 외부 코드나 로직의 주입을 막는다는 것이 헥사고날 아키텍처의 핵심

## 다른 프로젝트에서 Jenkins를 사용하셨던데, GitHub Actions와 비교했을 때 각 기술의 장단점에 대해 알려주세요
- **Github Action**
  - 소스코드를 Git으로 대부분 관리하기에 간단한 CI/CD 워크플로우를 생성할 수 있다.
  - Yaml으로 설정하기에 간편
  - 푸시(push), 풀 리퀘스트(pull request), 이슈(issue) 등과 같은 이벤트에 대한 자동 실행을 지원합니다.
  - **하지만**, 더 복잡한 CI/CD 워크플로우를 구현하려면 특정 작업 및 스크립트를 작성해야한다.
  - GitHub Actions는 GitHub에서 호스팅되므로 외부 CI/CD 서비스와는 달리 GitHub 계정이 필요로하기에 Github를 사용하지않는 환경에서는 부적절
- **Jenkins**
  - 다양한 플러그인을 기반으 커스터마이징하기에 좋다.
  - 하지만 그만큼 복잡하며, 자체 호스팅 관리를 해야한다.

## 필터라 함은 spring에서의 servlet 필터를 말씀하시는 건가요? 맞다면 인터셉터가 아닌 필터에 구현하신 이유가 궁금합니다.
- 네 Servlet의 Req,Res를 처리할 수 있는 Filter클래스를 확장구현한 OnePerRequestFilter를 이용하여 구현했습니다.
- 필터로 만약 인증인가를 처리할 경우 컨트롤러 메서드 전후에 실행되는 특성상, 해당 컨트롤러까지 도달하는 자원이 낭비가됩니다.
- 그렇기에 필터로 구현하면, 더빠른 응답과 리소스를 절약할 수 있습니다.
- 디스패처 서블릿(Dispatcher Servlet)에 요청이 가기전 처리하는 편이 좋다.
- 인터셉터는 디스패처 서블릿(Dispatcher Servlet)이 컨트롤러를 호출하기 전과 후
- 필터는 모든 HTTP 요청에 대해 실행되므로 세부적인 로깅, 보안 검사, 인증 및 권한 부여와 같은 작업에 유용
- 인터셉터를 아예구현안하는건 아닐수도있다. 예를들어 채팅서비스를 만들때 채팅을 보내는사람이 유효한 인가를 가지고있는지 판단하는데에도 사용가능

