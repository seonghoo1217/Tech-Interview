# 프로세스 & 스레드
> - 프로세스 : 프로그램을 메모리 상에서 실행중인 작업이자 코드로 작성된 프로그램이 메모리에 적재되어 사용할 수 있는 상태
> 
> - 스레드 : 프로세스 안에서 실행되는 여러 흐름 단위이자 프로세스(process) 내에서 실제로 작업을 수행하는 주체

 하나의 프로세스는 기본적으로 1개의 스레드를 반드시 소유한다.(메인 스레드를 포함하여)
 
![](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)

## 프로세스 구조
- **Code** : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
- **Data** : 전역변수, 정적변수, 배열 등
  - **초기화 된 데이터**는 data 영역에 저장
  - **초기화 되지 않은 데이터**는 BSS(Binary Search Space) 영역에 저장
- **Heap** : 동적 할당 시 사용 (new(), malloc() 등)
- **Stack** : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)
- 각각의 스레드는 Stack만 따로 할당 받고 **나머지 영역**은 서로 공유한다.
- 하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드 같이 생성이 된다.
- 프로세스는 **자신만의 고유 공간**과 자원을 할당받아 사용하는데 반해, 스레드는 다른 스레드와 공간, **자원을 공유**하면서 사용하는 차이가 존재한다.

### 멀티 프로세스(Multi-Process)
- 하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하는 것
- **장점** 
  - 독립된 구조로 안전성이 높다 (메모리 침범 문제를 OS 차원에서 해결)
  - 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않아, 작업속도가 느려지는 손해 정도는 생기지만 정지되거나 하는 문제는 발생하지 않는다.
  - 여러 개의 프로세스가 처리되어야 할 때 동일한 데이터를 공유해서 사용하기에, 작업비용이 저렴
- **단점** 
  - 각각 독립된 메모리 영역을 갖고 있어, 작업량 많을 수록 오버헤드 발생. Context Switching으로 인한 성능 저하
  - 특히나 프로세스를 컨텍스트 스위칭 하면, CPU는 다음 프로세스의 정보를 불러오기 위해 메모리를 검색하고, CPU 캐시 메모리를 초기화하며, 프로세스 상태를 저장하고, 불러올 데이터를 준비해야 하기 때문에, 이로 인한 빈번한 Context Switching 작업으로 인해 비용 오버헤드가 발생
    - 따라서 멀티 프로세스 환경에서는 Context Switching Overhead를 최소화하는 방법이 중요하다.

### Context Switching
**Context Switching의 목적**
- Computer가 여러 Task를 한번에 처리하는 것이 주 목적이다.
- 빠른 속도로 Task를 바꿔 가며 실행하기 때문에 사람의 눈으론 실시간처럼 보이게 되는 장점
  - 이과정에서 여러 작업이 동시에 수행되기 위해, Computer multitasking을 이용해 사용된다.
  - CPU가 Task를 바꿔 가며 실행하기 위해 Context Switching을 수행한다.

**Context Switching의 동작 방식**
- Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리된다.
- 현재 실행하고 있는 Task의 PCB 정보를 저장한다. (Process Stack, Ready Queue)
- 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행한다.


> 💡프로세스 제어 블록(PCB, Process Control Block)
> - 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는, 운영체제 커널의 자료구조
> - 운영체제가 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보를 가지고 있는 데이터베이스를 PCB라한다.
> - 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거

- 프로세스의 상태 정보를 저장하고 복원하는 과정
- 동작 중인 프로세스가 대기하면서 해당 프로세스 또는 스레드의 **상태(Conetxt)** 를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정

## 멀티 스레드(Multi-Thread)
- 하나의 프로세스에 여러 스레드로 **자원을 공유(Code,Data,Heap)** 하며 작업을 나누어 수행

![](https://user-images.githubusercontent.com/48986787/126673676-992e01be-01a1-41cc-9a07-f5d6c2f2bba4.png)

- **장점**
  - 시스템 자원 소모 감소 (자원의 효율성이 증가한다, 공유함으로)
  - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어 자원을 효율적으로 관리
  - 레드 사이 작업량이 적어 Context Switching이 빠르다. 
  - 힙 영역을 공유하므로 데이터를 주고받을 수 있다.
  - 스레드는 프로세스 내 스택 영역을 제외한 메모리 영역을 공유하기에 멀티 프로세스 환경에 비해, 통신비용이 적다.
- **단점**
  - 자원을 공유하기에 동기화 문제가 발생(병목현상 및 데드락)
  - 하나의 스레드에 문제가 생기면 전체 프로세스가 영향

## 멀티 프로세스 VS 멀티 스레드
- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료 될 위험을 갖고 있다.
- 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지하는 단점이 있다.
- 두 방법은 동시에 여러 작업을 수행하는 점에서 동일하지만, 각각의 장단이 있으므로 적용하는 시스템에 따라 적합한 동작 방식을 선택하고 적용해야 한다.

## 스레드를 쓰는 이유
- 운영체제가 시스템 자원을 효율적으로 관리하기 위해 스레드를 사용한다.
- 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
- 또한, 프로세스 간의 통신보다 스레드 간의 통신 비용이 적으므로 작업들 간 통신의 부담이 줄어든다. (처리비용 감소. 프로세스는 독립구조이기 때문)